"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const prop_types_1 = __importDefault(require("prop-types"));
const cli_cursor_1 = __importDefault(require("cli-cursor"));
const AppContext_1 = __importDefault(require("./AppContext"));
const StdinContext_1 = __importDefault(require("./StdinContext"));
const StdoutContext_1 = __importDefault(require("./StdoutContext"));
const StderrContext_1 = __importDefault(require("./StderrContext"));
const FocusContext_1 = __importDefault(require("./FocusContext"));
const TAB = '\t';
const SHIFT_TAB = '\u001B[Z';
const ESC = '\u001B';
// Root component for all Ink apps
// It renders stdin and stdout contexts, so that children can access them if needed
// It also handles Ctrl+C exiting and cursor visibility
let App = /** @class */ (() => {
    class App extends react_1.PureComponent {
        constructor() {
            super(...arguments);
            this.state = {
                isFocusEnabled: true,
                activeFocusId: undefined,
                focusIds: [],
                disabledFocusIds: []
            };
            // Count how many components enabled raw mode to avoid disabling
            // raw mode until all components don't need it anymore
            this.rawModeEnabledCount = 0;
            this.handleSetRawMode = (isEnabled) => {
                const { stdin } = this.props;
                if (!this.isRawModeSupported()) {
                    if (stdin === process.stdin) {
                        throw new Error('Raw mode is not supported on the current process.stdin, which Ink uses as input stream by default.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported');
                    }
                    else {
                        throw new Error('Raw mode is not supported on the stdin provided to Ink.\nRead about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported');
                    }
                }
                stdin.setEncoding('utf8');
                if (isEnabled) {
                    // Ensure raw mode is enabled only once
                    if (this.rawModeEnabledCount === 0) {
                        stdin.addListener('data', this.handleInput);
                        stdin.resume();
                        stdin.setRawMode(true);
                    }
                    this.rawModeEnabledCount++;
                    return;
                }
                // Disable raw mode only when no components left that are using it
                if (--this.rawModeEnabledCount === 0) {
                    stdin.setRawMode(false);
                    stdin.removeListener('data', this.handleInput);
                    stdin.pause();
                }
            };
            this.handleInput = (input) => {
                // Exit on Ctrl+C
                // eslint-disable-next-line unicorn/no-hex-escape
                if (input === '\x03' && this.props.exitOnCtrlC) {
                    this.handleExit();
                }
                // Reset focus when there's an active focused component on Esc
                if (input === ESC && this.state.activeFocusId) {
                    this.setState({
                        activeFocusId: undefined
                    });
                }
                if (this.state.isFocusEnabled && this.state.focusIds.length > 0) {
                    if (input === TAB) {
                        this.setState(({ activeFocusId, focusIds }) => {
                            if (!activeFocusId) {
                                return {
                                    activeFocusId: focusIds[0]
                                };
                            }
                            const index = focusIds.indexOf(activeFocusId);
                            const nextId = focusIds[index + 1] || focusIds[0];
                            return {
                                activeFocusId: nextId
                            };
                        });
                    }
                    if (input === SHIFT_TAB) {
                        this.setState(({ activeFocusId, focusIds }) => {
                            if (!activeFocusId) {
                                return {
                                    activeFocusId: focusIds[0]
                                };
                            }
                            const index = focusIds.indexOf(activeFocusId);
                            const nextId = focusIds[index - 1] || focusIds[focusIds.length - 1];
                            return {
                                activeFocusId: nextId
                            };
                        });
                    }
                }
            };
            this.handleExit = (error) => {
                if (this.isRawModeSupported()) {
                    this.handleSetRawMode(false);
                }
                this.props.onExit(error);
            };
            this.enableFocus = () => {
                this.setState({
                    isFocusEnabled: true
                });
            };
            this.disableFocus = () => {
                this.setState({
                    isFocusEnabled: false
                });
            };
            this.registerFocusComponent = (id) => {
                // If this is a first component to register, make it active immediately
                this.setState(({ activeFocusId, focusIds }) => ({
                    activeFocusId: focusIds.length === 0 ? id : activeFocusId,
                    focusIds: [...focusIds, id]
                }));
            };
            this.unregisterFocusComponent = (id) => {
                this.setState(previousState => ({
                    activeFocusId: previousState.activeFocusId === id
                        ? undefined
                        : previousState.activeFocusId,
                    focusIds: previousState.focusIds.filter(focusId => focusId !== id)
                }));
            };
            this.enableFocusComponent = (id) => {
                this.setState(previousState => ({
                    disabledFocusIds: previousState.disabledFocusIds.filter(disabledId => {
                        return disabledId !== id;
                    })
                }));
            };
            this.disableFocusComponent = (id) => {
                this.setState(previousState => ({
                    activeFocusId: previousState.activeFocusId === id
                        ? undefined
                        : previousState.activeFocusId,
                    disabledFocusIds: [...previousState.disabledFocusIds, id]
                }));
            };
        }
        // Determines if TTY is supported on the provided stdin
        isRawModeSupported() {
            return this.props.stdin.isTTY;
        }
        render() {
            return (react_1.default.createElement(AppContext_1.default.Provider, { value: {
                    exit: this.handleExit,
                    enableFocus: this.enableFocus,
                    disableFocus: this.disableFocus
                } },
                react_1.default.createElement(StdinContext_1.default.Provider, { value: {
                        stdin: this.props.stdin,
                        setRawMode: this.handleSetRawMode,
                        isRawModeSupported: this.isRawModeSupported()
                    } },
                    react_1.default.createElement(StdoutContext_1.default.Provider, { value: {
                            stdout: this.props.stdout,
                            write: this.props.writeToStdout
                        } },
                        react_1.default.createElement(StderrContext_1.default.Provider, { value: {
                                stderr: this.props.stderr,
                                write: this.props.writeToStderr
                            } },
                            react_1.default.createElement(FocusContext_1.default.Provider, { value: {
                                    activeId: this.state.activeFocusId,
                                    register: this.registerFocusComponent,
                                    unregister: this.unregisterFocusComponent,
                                    enable: this.enableFocusComponent,
                                    disable: this.disableFocusComponent
                                } }, this.props.children))))));
        }
        componentDidMount() {
            cli_cursor_1.default.hide(this.props.stdout);
        }
        componentWillUnmount() {
            cli_cursor_1.default.show(this.props.stdout);
            // ignore calling setRawMode on an handle stdin it cannot be called
            if (this.isRawModeSupported()) {
                this.handleSetRawMode(false);
            }
        }
        componentDidCatch(error) {
            this.handleExit(error);
        }
    }
    App.displayName = 'InternalApp';
    App.propTypes = {
        children: prop_types_1.default.node.isRequired,
        stdin: prop_types_1.default.object.isRequired,
        stdout: prop_types_1.default.object.isRequired,
        stderr: prop_types_1.default.object.isRequired,
        writeToStdout: prop_types_1.default.func.isRequired,
        writeToStderr: prop_types_1.default.func.isRequired,
        exitOnCtrlC: prop_types_1.default.bool.isRequired,
        onExit: prop_types_1.default.func.isRequired
    };
    return App;
})();
exports.default = App;
//# sourceMappingURL=Focus.js.map