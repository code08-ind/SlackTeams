"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const prop_types_1 = __importDefault(require("prop-types"));
const childrenToArray = (children) => {
    return Array.isArray(children) ? children : [children];
};
/**
 * `<Static>` component allows permanently rendering output to stdout and preserving it across renders. Components passed to `<Static>` as children will be written to stdout only once and will never be rerendered. `<Static>` output comes first, before any other output from your components, no matter where it is in the tree. In order for this mechanism to work properly, at most one `<Static>` component must be present in your node tree and components that were rendered must never update their output. Ink will detect new children appended to `<Static>` and render them to stdout.
 *
 * __Note__: `<Static>` accepts only an array of children and each of them must have a unique key.
 *
 * This component allows developers to render output before main output from all the other components.
 * The reason it's called <Static> is it's append-only output. Output from <Static> components
 * is written permanently to stdout and is never updated afterwards. If <Static> component
 * receives new children, Ink will detect the changes and write them to stdout.
 * In order for this mechanism to work perfectly, <Static> children must never update their output
 * once they've been appended to <Static>.
 *
 * A good example of where this component might be useful is interface like Jest's.
 * When running tests, Jest keeps writing completed tests to output, while continuously
 * rendering test stats at the end of the output.
 */
class DeprecatedStatic extends react_1.Component {
    constructor() {
        super(...arguments);
        this.state = {
            lastIndex: null
        };
    }
    render() {
        const _a = this.props, { children } = _a, otherProps = __rest(_a, ["children"]);
        const { lastIndex } = this.state;
        let newChildren = children;
        if (typeof lastIndex === 'number') {
            newChildren = childrenToArray(children).slice(lastIndex);
        }
        return (react_1.default.createElement("div", { 
            // @ts-ignore
            unstable__static: true, style: Object.assign({ position: 'absolute', flexDirection: 'column' }, otherProps) }, newChildren));
    }
    componentDidMount() {
        this.saveLastIndex(this.props.children);
    }
    componentDidUpdate(_prevProps, prevState) {
        if (prevState.lastIndex === this.state.lastIndex) {
            this.saveLastIndex(this.props.children);
        }
    }
    saveLastIndex(children) {
        const nextIndex = childrenToArray(children).length;
        if (this.state.lastIndex !== nextIndex) {
            this.setState({
                lastIndex: nextIndex
            });
        }
    }
}
exports.DeprecatedStatic = DeprecatedStatic;
DeprecatedStatic.propTypes = {
    children: prop_types_1.default.node
};
//# sourceMappingURL=DeprecatedStatic.js.map