"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const measure_text_1 = require("./measure-text");
const wrap_text_1 = require("./wrap-text");
const get_max_width_1 = require("./get-max-width");
// Since we need to know the width of text container to wrap text, we have to calculate layout twice
// This function is executed after first layout calculation to reassign width and height of text nodes
exports.calculateWrappedText = (node) => {
    var _a;
    if (node.nodeName !== '#text') {
        if (node.textContent &&
            typeof ((_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.style.textWrap) === 'string') {
            const { yogaNode: parentYogaNode } = node.parentNode;
            const maxWidth = parentYogaNode ? get_max_width_1.getMaxWidth(parentYogaNode) : 0;
            const { yogaNode } = node;
            if (yogaNode) {
                const currentWidth = yogaNode.getComputedWidth();
                if (currentWidth > maxWidth) {
                    const { textWrap } = node.parentNode.style;
                    const wrappedText = wrap_text_1.wrapText(node.textContent, maxWidth, {
                        textWrap
                    });
                    const { width, height } = measure_text_1.measureText(wrappedText);
                    yogaNode.setWidth(width);
                    yogaNode.setHeight(height);
                }
            }
        }
        for (const childNode of node.childNodes) {
            exports.calculateWrappedText(childNode);
        }
    }
};
//# sourceMappingURL=calculate-wrapped-text.js.map